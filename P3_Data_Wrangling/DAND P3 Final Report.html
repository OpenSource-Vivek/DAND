<html>
<head>
  <title>Evernote Export</title>
  <basefont face="Tahoma" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (en-US, DDL); Windows/10.0.14393 (Win64);"/>
  <style>
    body, td {
      font-family: Tahoma;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="8530"/>

<div>
<span><div><span style="font-size: 21px;"><b>OpenStreetMap Data Case Study</b></span></div><div><br/></div><div>Scott Tse</div><div>2016-11-16</div><div><br/></div><div><br/></div><div>I chose to investigate the OSM data for the city of Portland, OR where I currently reside. I hope to continue to work with OSM data in the future and contribute to open data projects in Portland.</div><div><br/></div><div>OSM link for Portland, OR:</div><div>https://www.openstreetmap.org/search?query=portland%2C%20or#map=12/45.5234/-122.6762</div><div><br/></div><div>I extracted the compressed OSM data in XML format (84MB) from MAPZEN, following this link:</div><div><a href="https://mapzen.com/data/metro-extracts/metro/portland_oregon/">https://mapzen.com/data/metro-extracts/metro/portland_oregon/</a></div><div><br/></div><div>For the reduced dataset for grading, I submitted an OSM file titled &quot;sample.osm&quot; (3MB).</div><div><br/></div><div><u><span style="font-size: 15px;"><b>Problems Encountered in the OSM Data for Portland</b></span></u></div><div><br/></div><div>In general, I found the OSM data quite clean. I had to search for issues to clean.</div><div><br/></div><div>In addition to street names, I also audited the 'k' attributes 'names' and 'landuse' and found some issues that I addressed.</div><div><br/></div><ul><li>For street names, I  found multiple abbreviations for common street types such as Street (&quot;St.&quot;, &quot;St&quot;), Avenue (&quot;Ave&quot;, &quot;Ave.&quot;), Drive (&quot;Dr&quot;, &quot;Dr.&quot;),  and Boulevard (&quot;Blvd&quot;, &quot;Blvd.&quot;). My approach to this issue was simply to map the abbreviations to the full street type.  For instance, any instance of &quot;Ave.&quot; was transformed to &quot;Avenue&quot;.</li><li>For k attribute 'landuse', I found multiple values related to farms (farm, farmyard, farmland). To me these, attribute values seemed too specific without adding much information so I mapped them all to the value &quot;farm&quot;.</li><li>For k attribute 'name', I found two types of values referring the coffee purveyor Starbucks (&quot;Starbucks&quot; and also &quot;Starbucks Coffee&quot;). If one were interested in investigating the occurrence of Starbucks within Portland (a high likelihood since our sun deprived existence seems to leave us wanting for caffeine and beer), I though it best to standardize any reference to &quot;Starbucks&quot; in the 'name' value to the full name &quot;Starbucks Coffee&quot;. Although I recognize that once loaded into a database, one can look for the occurrence of the string &quot;Starbucks&quot; in the name column, cleaning it upfront before loading into the database can only reduce potential errors and confusion. </li></ul><div><br/></div><div><b>Street Names</b></div><div><br/></div><div>I used the following code to investigate the street names info:</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>def audit_street_type(street_types, street_name):</div><div>    m = street_type_re.search(street_name)</div><div>    if m:</div><div>        street_type = m.group() # grabs output of regex (last part of string) and assigns to street_type</div><div>        if street_type not in expected:</div><div>            street_types[street_type].add(street_name)</div><div><br/></div><div># this function returns True if the k element is &quot;addr:street&quot;</div><div>def is_street_name(elem):</div><div>    return (elem.attrib['k'] == &quot;addr:street&quot;)</div><div><br/></div><div># this is the main audit function</div><div># takes osmfile and opens it</div><div># creates street_types dictionary of sets</div><div><br/></div><div>def audit(osmfile):</div><div>    osm_file = open(osmfile, &quot;r&quot;)</div><div>    street_types = defaultdict(set)</div><div>    # for all node and way tags, iterate through the child tags and if the tag is &quot;tag&quot;</div><div>    # check if it's a stree name: if yes, then call audit_street_type function</div><div>    #for event, elem in ET.iterparse(osm_file, events=(&quot;start&quot;,)):</div><div>    for i, elem in enumerate(get_element(osmfile)):    # inserted this to preserve memory</div><div><br/></div><div>        if elem.tag == &quot;node&quot; or elem.tag == &quot;way&quot;:</div><div>            for tag in elem.iter(&quot;tag&quot;):</div><div>                if is_street_name(tag):</div><div>                    audit_street_type(street_types, tag.attrib['v'])</div><div>    osm_file.close()</div><div>    return street_types</div><div><br/></div></div><div><br/></div><div>For unexpected street names not in this list below,</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>expected = [&quot;Street&quot;, &quot;Avenue&quot;, &quot;Boulevard&quot;, &quot;Drive&quot;, &quot;Court&quot;, &quot;Place&quot;, &quot;Square&quot;, &quot;Lane&quot;, &quot;Road&quot;,</div><div>            &quot;Trail&quot;, &quot;Parkway&quot;, &quot;Commons&quot;, &quot;Terrace&quot;, &quot;Circle&quot;, &quot;Circus&quot;, &quot;Crescent&quot;, &quot;Crest&quot;, &quot;East&quot;, &quot;End&quot;,</div><div>            &quot;Highway&quot;, &quot;Loop&quot;, &quot;North&quot;, &quot;Run&quot;, &quot;Terrace&quot;, &quot;Way&quot;]</div></div><div><br/></div><div>The function outputs a dictionary of unexpected street type occurrences, with the following structure {unexpected street type: set[street type values]</div><div><br/></div><div>For example, in the case of the unexpected street type 'Ave.' this is the output within dictionary:</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>'Ave.': set(['NW 19th Ave.', 'Northeast 122ND Ave.'])</div></div><div><br/></div><div><b><br/></b></div><div><b>Landuse</b></div><div><br/></div><div>For k attribute 'landuse' utilizing the function att_info, I output a set of values: </div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>set(['basin',<br/>
    'brownfield',<br/>
    'cemetery',<br/>
    'commercial',<br/>
    'construction',<br/>
    'farm',<br/>
    'farmland',<br/>
    'farmyard',<br/>
    'forest',<br/>
    'garages',<br/>
    'government',<br/>
    'grass',<br/>
    'greenhouse_horticulture',<br/>
    'industrial',<br/>
    'landfill',<br/>
    'meadow',<br/>
    'military',<br/>
    'orchard',<br/>
    'plant_nursery',<br/>
    'quarry',<br/>
    'railway',<br/>
    'reservoir',<br/>
    'residential',<br/>
    'retail',<br/>
    'village_green',</div><div>    'vineyard'])</div></div><div><br/></div><div>As stated above, I thought that having 3 values related to farms was confusing and more specific than some of the examples in the set. To simplify, I mapped all related values to 'farm' as follows:</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>#create mappings for k attribute 'landuse'</div><div><br/></div><div>landuse_mapping = [&quot;farmland&quot;, &quot;farmyard&quot;]</div><div><br/></div><div>def is_landuse(elem):</div><div>    return (elem.attrib['k'] == &quot;landuse&quot;)</div><div><br/></div><div>def update_landuse(name, landuse_mapping):</div><div>    if name in landuse_mapping:</div><div>        name = &quot;farm&quot;</div><div>    return name   </div></div><div><br/></div><div><br/></div><div><b>Starbucks</b></div><div><br/></div><div>I audited values under the k attribute 'name' which returned a large list, but I noticed 'v' values 'Starbucks' and 'Starbucks Coffee'.  I decided to map all 'Starbucks'  to 'Starbucks Coffee to reduce ambiguity. </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>#create mappings for k attribute 'name' Starbucks</div><div><br/></div><div>starbucks_mapping = [&quot;Starbucks&quot;]</div><div><br/></div><div>def is_name(elem):</div><div>    return (elem.attrib['k'] == &quot;name&quot;)</div><div><br/></div><div>def update_name_starbucks(name, starbucks_mapping):</div><div>    if name in starbucks_mapping:</div><div>        name = &quot;Starbucks Coffee&quot;</div><div>    return name </div></div><div><br/></div><div>I then used the functions shape_element and process_map  to create dictionaries which would then be parsed into csv files nodes,  nodes_tags, ways, ways_tags, and ways_nodes. I then created appropriate tables in sqlite3 with this schema suggested (<a href="https://gist.github.com/swwelch/f1144229848b407e0a5d13fcb7fbbd6f">https://gist.github.com/swwelch/f1144229848b407e0a5d13fcb7fbbd6f</a>) and imported the data.</div><div><br/></div><div><br/></div><div><u><span style="font-size: 15px;"><b>SQL Queries</b></span></u></div><div><br/></div><div>How many nodes and rows in the other tables:</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>ANALYZE</div><div>SELECT * FROM sqlite_stat1;</div></div><div><br/></div><div>returns the following row count statistics:</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>ways_nodes||7445818</div><div>ways_tags||4605699</div><div>ways||835807</div><div>nodes_tags||275260</div><div>nodes||6501883</div></div><div><br/></div><div><br/></div><div>How many unique users:</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>SELECT COUNT(DISTINCT subq.uid) FROM</div><div>(SELECT uid FROM nodes</div><div>UNION</div><div>SELECT uid FROM ways) as subq;</div></div><div> returns </div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>1179</div></div><div><br/></div><div><br/></div><div>How many Starbucks Coffees?</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>SELECT count(*) FROM</div><div>(</div><div>SELECT * FROM nodes_tags WHERE key = 'name' AND value like UPPER('%Starbucks%')</div><div>UNION</div><div>SELECT * FROM ways_tags WHERE key = 'name' AND value like UPPER('%Starbucks%')</div><div>) as subq</div><div>;</div></div><div>returns</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>196</div></div><div><br/></div><div><br/></div><div>What are the different types of landuse and how many of each type are there for the top 10?</div><div><br/></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>SELECT subq.value, COUNT(subq.value) as num</div><div>FROM</div><div>(</div><div>SELECT * FROM nodes_tags WHERE key = 'landuse'</div><div>UNION</div><div>SELECT * FROM ways_tags WHERE key = 'landuse'</div><div>) as subq</div><div>GROUP BY subq.value</div><div>ORDER BY num DESC</div><div>LIMIT 10;</div></div><div>returns</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>residential|1062</div><div>grass|1055</div><div>farm|563</div><div>retail|522</div><div>reservoir|347</div><div>commercial|260</div><div>industrial|249</div><div>forest|169</div><div>cemetery|160</div><div>quarry|102</div></div><div><br/></div><div><br/></div><div>How many different types of landuse?</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>SELECT COUNT(DISTINCT subq.value) as num</div><div>FROM</div><div>(</div><div>SELECT * FROM nodes_tags WHERE key = 'landuse'</div><div>UNION</div><div>SELECT * FROM ways_tags WHERE key = 'landuse'</div><div>) as subq;</div></div><div>returns</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>36</div></div><div><br/></div><div><br/></div><div>Which user has contributed the most entries to the Starbucks? Show the top 5 users.</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>SELECT nodes.uid, user, count(*) as num FROM nodes JOIN nodes_tags</div><div>ON nodes.id = nodes_tags.id</div><div>WHERE nodes_tags.key = 'name' AND nodes_tags.value = 'Starbucks Coffee'</div><div>GROUP BY nodes.uid, user</div><div>ORDER BY num DESC</div><div>LIMIT 5;</div></div><div>returns</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>81676|Peter Dobratz|44</div><div>3125856|cowdog|29</div><div>628788|marshall2389|7</div><div>97431|Dion Dock|6</div><div>1442206|roadgeek99|6</div></div><div><br/></div><div><br/></div><div><u><span style="font-size: 15px;"><b>Opportunities for Improvement and Future Work</b></span></u></div><div><br/></div><div>This dataset has many opportunities for further investigation. For one thing, I did not dive into the tags related to TIGER data at all primarily because I do not have a firm grasp on TIGER. I did some preliminary research into TIGER at (<a href="http://wiki.openstreetmap.org/wiki/TIGER">http://wiki.openstreetmap.org/wiki/TIGER</a>) and would like to understand how TIGER data is integrated into OSM and how it related to other data input by users. Another questions for me is now that I've done some data cleaning and auditing, how do I know if I should submit these changes to the OSM project? So some research into conventions for submitting changes is warranted.  I also noticed that Starbucks Coffee is disproportionately represented in the dataset, over other coffee retailers. Portland is renowned for its independent coffee culture so working on inputting data for other coffee shops would make the OSM more truly representative.</div><div><br/></div><div>On a more serious note, I have an interest in emergency preparedness vis a vis &quot;the Big One&quot; ie the massive Cascadia Subduction Zone Earthquake that Portland and the Pacific NW region of USA/Canada are at risk for. Auditing the data and doing analytics on the types of resources (health clinics, water sources, emergency responders) that may be predictive of survival could be useful to my fellow citizens.</div><div><br/></div><div><br/></div><div><u><span style="font-size: 16px;"><b>Conclusion</b></span></u></div><div><br/></div><div>In this project I have had the chance to perform data wrangling in python and perform SQL analysis on the OSM data for my hometown, Portland, OR, USA.  The data seems to be quite clean, which is not surprising given Portland's tech savvy citizenry as well as its penchant for civic engagement. I assume these factors could be correlated with a relatively high quality of data input into OSM for my region.  In this project, I have demonstrated the process of data auditing and cleaning on an XML data set in excess of 50MB.</div><div><br/></div><div><br/></div></span>
</div></body></html> 